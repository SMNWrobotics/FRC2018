// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1982.the2018Bot.commands;
import org.usfirst.frc1982.the2018Bot.Robot;
import org.usfirst.frc1982.the2018Bot.RobotMap;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.hal.HAL;
import edu.wpi.first.wpilibj.hal.FRCNetComm.tInstances;
import edu.wpi.first.wpilibj.hal.FRCNetComm.tResourceType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class driveEnable extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public driveEnable() {
    	requires(Robot.drive);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	RobotMap.driveLeft.setSelectedSensorPosition(0, 0, 0);
    	RobotMap.driveRight.setSelectedSensorPosition(0, 0, 0);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
//    	RobotMap.driveTrain.arcadeDrive(-Robot.oi.xbox.getY(), Robot.oi.xbox.getThrottle());
//    	SmartDashboard.putNumber("Turning value:", Robot.oi.xbox.getThrottle());
    	
    	
//    	RobotMap.driveLeft.set(-Robot.oi.xbox.getY());
//    	RobotMap.driveRight.set(-Robot.oi.xbox.getY());
//    	RobotMap.driveleftSlave.set(-Robot.oi.xbox.getY());
//    	RobotMap.driverightSlave.set(-Robot.oi.xbox.getY());
    	
    	arcadeDrive(-Robot.oi.xbox.getY(), Robot.oi.xbox.getThrottle());
    	
    }
    
    private double limit(double input) {
    	if (input > 1.0) {
    		input = 1.0;
    	} else if (input < -1.0) {
    		input = -1.0;
    	}
    	return input;
    }
    
    private void arcadeDrive(double xSpeed, double zRotation) {
        xSpeed = limit(xSpeed);
//        xSpeed = applyDeadband(xSpeed, m_deadband);

        zRotation = limit(zRotation);
//        zRotation = applyDeadband(zRotation, m_deadband);

//        // Square the inputs (while preserving the sign) to increase fine control
//        // while permitting full power.
//        if (squaredInputs) {
//          xSpeed = Math.copySign(xSpeed * xSpeed, xSpeed);
//          zRotation = Math.copySign(zRotation * zRotation, zRotation);
//        }

        double leftMotorOutput;
        double rightMotorOutput;

        double maxInput = Math.copySign(Math.max(Math.abs(xSpeed), Math.abs(zRotation)), xSpeed);

        if (xSpeed > 0.0) {
          // First quadrant, else second quadrant
          if (zRotation >= 0.0) {
            leftMotorOutput = maxInput;
            rightMotorOutput = xSpeed - zRotation;
          } else {
            leftMotorOutput = xSpeed + zRotation;
            rightMotorOutput = maxInput;
          }
        } else if (xSpeed < 0.0){
          // Third quadrant, else fourth quadrant
          if (zRotation >= 0.0) {
            leftMotorOutput = xSpeed + zRotation;
            rightMotorOutput = maxInput;
          } else {
            leftMotorOutput = maxInput;
            rightMotorOutput = xSpeed - zRotation;
          }
        }else {
        	 leftMotorOutput = zRotation;
             rightMotorOutput = -zRotation;
        }

        RobotMap.driveLeft.set(limit(leftMotorOutput));
        RobotMap.driveleftSlave.set(limit(leftMotorOutput));
        
        RobotMap.driveRight.set(limit(rightMotorOutput));
        RobotMap.driverightSlave.set(limit(rightMotorOutput));
      }
    
    
    
    /*
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     */
    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
